Передрий Михаил Сергеевич, P34102
Вариант: 8, 21
=====
# Problem 8. Largest Product in a Series
### Требуется найти наибольшее произведение n(13) последовательных цифр в последовательности.
### Рекурсия
Как и в последующих решениях, используется вспомогательная функция, вычисляющая произведение первых n элементов списка.

На каждом шаге рекурсии считаем произведение, отрезаем голову, рекурсивно вызываемся, возвращаем максимум.
```erlang
solve([Head | Tail], N) ->
    max(common8:product_of_n([Head | Tail], N), solve(Tail, N));
solve(_, _) ->
    0.
```

### Хвостовая рекурсия
Аналогично, но передаем в функцию текущий максимум. Когда список становится пустым, возвращаем максимум.
```erlang
solve([Head | Tail], N, Max) ->
    solve(Tail, N, max(Max, common8:product_of_n([Head | Tail], N)));
solve(_, _, Max) ->
    Max.
```

### Модульная
Генерируем список произведений первых n элементов списков, начинающихся с текущего индекса в исходном списке.

Сворачиваем список максимумом.
```erlang
gen([Head | Tail], N) ->
    [common8:product_of_n([Head | Tail], N) | gen(Tail, N)];
gen(_, _) ->
    [].

solve(List, N) ->
    lists:foldl(fun max/2, 0, gen(List, N)).
```

# Problem 21. Amicable Numbers
### Требуется найти сумму чисел меньших n, таких, что сумма их делителей совпадает с суммой делителей суммы делителей.
### Рекурсия
Как и в последующих решениях, используется вспомогательная функция, проверяющая число на соответствие описанному свойству.

На каждом шаге рекурсии проверяем число на соответствие свойству, рекурсивно вызываемся, если число соответствует, возвращаем сумму числа и возврата из вызова, иначе просто возврат вызова.
```erlang
solve(0) ->
    0;
solve(N) ->
    case common21:is_amicable(N) of
        true -> N + solve(N - 1);
        false -> solve(N - 1)
    end.
```

### Хвостовая рекурсия
Аналогично, но передаем в функцию текущую сумму.
```erlang
solve(0, Acc) ->
    Acc;
solve(N, Acc) ->
    case common21:is_amicable(N) of
        true -> solve(N - 1, Acc + N);
        false -> solve(N - 1, Acc)
    end.
```

### Модульная
Генерируем список от 0 до n.

Отображаем список функцией, возвращающей само число, если оно соответствует свойству, иначе 0.

Сворачиваем список суммой.
```erlang
map_fn(N) ->
    case common21:is_amicable(N) of
        true -> N;
        false -> 0
    end.

solve(N) ->
    lists:foldl(fun (X, Acc) -> Acc + X end, 0, lists:map(fun map_fn/1, lists:seq(0, N))).
```


### Итератор над бесконечным списком
Итератор работает над бесконечным списком чисел, удовлетворяющих свойству.

Итератор является отдельным процессом. При получении сообщения next, посылает отправителю следующий элемент списка. При получении сообщения destroy, завершается.
```erlang
it_int_wait(N) ->
    receive
        {From, next} ->
            From ! N;
        destroy ->
            exit(ok);
        _ ->
            exit(unknown_msg)
    end.

it_int_routine(N) ->
    IsAmicable = common21:is_amicable(N),
    case IsAmicable of
        true ->
            it_int_wait(N),
            it_int_routine(N + 1);
        false ->
            it_int_routine(N + 1)
    end.

it_create() ->
    spawn(fun it_int_routine/0).

it_next(It) ->
    It ! {self(), next},
    receive
        Next ->
            Next
    end.

it_destroy(It) ->
    It ! destroy.
```

# Вывод
Выполняя задания, я смог взглянуть на стандартные задачи под другим углом. Erlang показался довольно приятным языком, позволяющим лакончино решать поставленные задачи. Больше всего понравился механизм ipc, по крайней мере то, что я успел увидеть.
